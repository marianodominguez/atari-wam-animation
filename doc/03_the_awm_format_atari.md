# The AWM File Format (Atari)

The Atari format is similar to the standard WAM file.  The control bytes are slightly different.  FA (Finished Animation), FD (Finished Drawing), and FE (Frame Extended) are the same as in WAM files.  However, instead of FF, FC (Frame Completed) signals the end of a frame.  Also, there are no control bytes to change color, since the Atari format being used doesn't allow multiple colors.  As with WAM files, the data is read in pairs with Y-coordinates listed first.  One big difference is that the X- coords range from 0 to 159 and Y-coords range from 0 to 95.  This is because AWM files are always played in GRAPHICS 22 mode (GRAPHICS 6 without text window - 160 x 96 resolution), and the AWM files must have the same resolution as the graphics screen, since the Atari doesn't have the power to modify the coordinates while the animation is played, the way the PC can.  I would have loved to use Atari's highest resolution mode (320 x 192), but it just wasn't possible, given the speed and memory constraints of the Atari.  Modifying the player to double the Y-resolution (GRAPHICS 30 mode, 160 x 192) wouldn't be that difficult, but the performance would definitely suffer and 12 frames per second would only be achieved for the simplest animations (not 100 line segments per frame).  So 160 x 96 resolution made the most sense.

The other difference is that AWM files start with 6 bytes which are "header bytes".  The first two are both FF, and the last four specify  the starting and ending memory locations where the file will be stored.  These 6 bytes indentify the file as an executable binary file, which it's not, but I have to make TurboBasic think it is, so the file can be loaded with TB's BLOAD (binary load) instruction.  These header bytes are not needed in PC WAM files, since those files don't need to be loaded into memory to be played.  The starting memory locations for the file (header bytes 3 and 4) require a little thought.  I found that 3200 hex (byte 3=00h, byte 4=32 h) works for the largest files (up to 30KB), but they can't be played using the BASIC version of the player (only the compiled version), since TurboBasic itself takes up too much memory to allow it.  If I want to play a file from TurboBasic, I start the file at 5200 hex.  In that case, the  file size is limited to about 21KB.  The ending memory location (header bytes 5 and 6) is calculated by adding the length of the file (not counting the header bytes) to the starting location (bytes 3 and 4).  When the file is loaded into memory by TB's BLOAD instruction, the header bytes are stripped off and the data is read correctly.


## A little history of the Atari (AWM) Player

The Atari Player is written in both compiled Turbo Basic and assembly language.  It resides on a bootable Atari disk which also contains AWM animations.  When the Atari is booted, control goes straight to a screen which lists the available animations and prompts the user to enter the name of the animation which will be played.  Next, the user is asked whether the animation will be played on a dark background (white lines on black, rather than black lines on white).  The user is then asked to enter "number of jiffies", which will determine how fast the animation is played (the frame rate).  A jiffy is 1/60 of a second, so if you wanted, for example, to play an animation at 12 frames per second, you would type "5" for number of jiffies (60 / 12 = 5).  The animation is then loaded and played, repeating each time from the beginning until the user hits BREAK, or reboots the Atari.  Pressing BREAK is convenient, because then the user can enter "R"at the prompt, which takes him back to the menu of available animations.

The player was originally written in standard Atari Basic.  I knew it would be incredibly slow, but it was a start.  The file "WHAM1.BAS" simply opens an AWM file, pulls the bytes from disk one at a time, and draws lines between them on the screen, using Basic's PLOT and DRAWTO instructions.  It tests the first byte in each pair of bytes to see whether it is a "command byte" or the Y-coordinate of the next endpoint to draw.  It uses the GRAPHICS 22 instruction to erase the screen between frames.  You see the screen being drawn each time, because "page flipping" (explained later) has not yet been implemented.  Its performance is, of course, dismal.  CAR.AWM (124 frames, 28,189 bytes) plays in 4 min, 22 sec. (at normal Atari floppy disk speed).  That's more than 2 sec per frame.  The finished Atari Player, by contrast, plays the same animation in 8.5 sec, more than 12 frames per second and a 30 times speed increase!

In the second version of the player (WHAM2.BAS), I loaded the entire animation file into memory using the POKE instruction, starting at a safe location (4000 hex).  This worked for small animations,  but files over 10KB were soon overwriting system routines and causing the Atari to crash.  Later I found that I could dimension one large variable to reserve up to 30KB for the animation, and keep it safe from anything the operating system was doing.  Anyway, POKEing the animation into memory one byte at a time was terribly slow, so I later discovered how to use TurboBasic's BLOAD routine to read the file into memory at machine language speeds.

You might be wondering at this point, how I was producing AWM movie files (or PC WAM files) in the first place.  The first movies were simply static 2D figures (boxes, etc) entered by hand with a hex editor.  This was very tedious, and I soon found a better source.  I had examined some animation files produced by the old Amiga 3D program, Forms-In-Flight.  I soon realized that these files were, like my files, collections of line endpoints (which allowed them to be sent to a plotter and also allowed the user to play them at several different resolutions).  In these files, X and Y coords were each 2 bytes, X-coords ranging from 0 to 10,240 and Y-coords ranging from 0 to 6400.  So I wrote a converter (FIF2WAM) in QuickBasic and later in Visual Basic, to convert Amiga Forms-In-Flight files to WAM and AWM files.  This gave me an ample supply of test animations, and for a while was satisfactory.  However, the converted files were larger than they needed to be (many times the same line was drawn over itself) and more importantly, it was difficult to produce interesting animations with Forms-In-Flight.  It was then I started work on WAMTrace, a Visual Basic program that I currently use to create WAM and AWM movies.  A set of BMP frames is created with a 2D or 3D animation program.  When the WHAMTrace program is run, these BMP pictures can be made to appear in the background of a window by the use of a slider bar.  The user can then trace lines on top of the BMP pictures, one frame at a time, and the data is automatically entered into a WAM file, playable on the PC.  That WAM file can then be converted to an Atari AWM file (lower resolution) with the Visual Basic program WAM2AWM.  One drawback of WAM and AWM files produced with WAMTrace is that the lines are "shakey".  This is partially because the tracing by a human is not perfect, and partially because some accuracy is lost when the file is scaled down from a 640 x 480 tracing to a 255 x 240 (or 160 x 96) file.  Another disadvantage is that the tracing is very tedious, and currently there is no easy way to stop a tracing in the middle, and work on it again later (groups of frames have to be joined together with a hex editor).  The big advantage of WAMTrace is that the BMP files used can come from anywhere, and sections of live video can be traced as easily as 3D or 2D animations.  Anyway, some feel that shaky animations can look "charming" and that tedious work is good for the soul, so this is the current way WAM and AWM movies are created.

For the 3rd version of the player (WHAM3A.BAS), I created the first machine language routine, which would clear the screen between frames.  I had been doing that with the GRAPHICS instruction, but I knew I could create something faster with machine language.  The Basic program first determined where in memory the screen data was stored.  Then the ML routine simply wrote zeros to all those  memory locations.  The routine, once tested with the Atari Assembler-Editor cartridge, was stored in DATA statements and read and POKEd into a safe area of memory.  With the next player, WHAM3B.BAS, the machine language screen clear routine was saved as a character string (CLEAR$) instead of as DATA statements.  This meant that I no longer had to find a place in memory to store the routine.  I thank Mark Chasin's Atari ML book for showing me the power of storing ML routines as character strings.  I would use this technique extensively later on...

WHAM4.BAS took a different approach to screen clearing.  Believe it or not, at this point I was still hoping to display AWM animations in GRAPHICS 24 mode (320 x 192) and I feared that the machine language screen clear routine would take too long.  So I modified the player to draw a frame normally, and then to draw the same lines in the background color to erase the frame.  I had anticipated that I would ultimately use machine language drawing routines, and that drawing in the background color would erase faster than my CLEAR$ routine.  I was soon to be proven wrong, especially in GRAPHICS 24 mode.



WHAM41.BAS added "page flipping" to the player in GRAPHICS 24, but it didn't work.  It was then I resigned myself to run the player in the lower resolution mode (WHAM41S.BAS - GRAPHICS 22) and stay with that mode from then on...


## Explanation of "Page Flipping"

Page flipping means that the program can draw lines on a screen that is not being displayed, while displaying a previously drawn screen.  When a drawing is finished, the displayed screen and the "hidden" screen are swapped, and the newly hidden screen is cleared and drawn on again.  This prevents the person watching the animation from seeing any lines being drawn, or any "flicker".  When it's time, the new frame just magically appears in the place of the old one.  The Atari can do this sort of thing because it supports multiple screens in different memory locations, and it can display them simply by moving the "screen pointer".  Another "pointer" tells the Atari where in memory to draw its dots and lines.  Anyway, page flipping was also achieved in  the the QuickBasic WHAM player (for PC), by using QuickBasic's PCOPY instruction.  I still haven't found a way to implement page flipping in the Visual Basic player, so that player still "flickers" somewhat.

WHAM5.BAS was identical to WHAM41S.BAS, except that it corrected the screen colors to be black-on-white (color registers 0 and 4 are used in GRAPHICS 22, instead of registers 1 and 2 used in GRAPHICS 24).

WHAMLO.BAS and WHAMHI.BAS used GRAPHICS 22 (160 x  96) and GRAPHICS 30 (160 x 192) modes, respectively.  They improved on WHAM5 in that now a file name could be entered, and a string variable (B$) was dimensioned to create a space for the animation data, which was then read and POKE'd in.  B$ was limited to 32KB for WHAMLO and 26KB for WHAMHI.  WHAMCLR.BAS brought the CLEAR$ routine back to the player and got rid of the background-draw-erase routine forever.  WHAMCLS. BAS cut down the memory area cleared to speed up the routine a little. From here on I stayed with GRAPHICS 22.

At this point, I knew I had gone as far as I could with Basic alone.  The line drawing, conditional testing, and looping speed would never be fast enough in Basic to play 12 FPS animations, even after the player was compiled.  It was time to get serious about ML...

I wrote a simple ML routine that would plot points on the screen by locating their memory locations and writing to them.  It was a little tricky, because in GRAPHICS 22 (as well as in GRAPHICS 30) there is one byte for each 8 pixels in a line (all pixels are just 2 color, 1 or 0 ).  Fortunately, the screen was 20 bytes across (160 pixels) so I could just multiply the Y-coord by 20 in ML (not too hard) to find the correct line.  I was then able to use the X-coord to locate the correct memory location (of the 20 for that line) and contruct a byte that was all zeros except for a "1" in the correct position.  I then ORed that byte with the existing value in the memory location (I used OR to avoid erasing any pixels from previously drawn lines).

Somewhere around this time I discovered Bresenham's line drawing algorthim.  I think I read it in an article about how Jack Bresenham was trying to control a plotter, working for IBM back in 1962.  Anyway, it's a nice "incremental" method of drawing lines, which can be done with integer math in ML, with very simple calculations.  It seemed perfect for my player, but if I implemented it, I needed to determine whether it was faster than accessing the Atari operating system drawing routines from ML, which seemed much easier to do.  But although I followed the instructions of Chasin and others, I was never able to get the operating system routines to work from ML.  So it was clearly up to me to write my own drawing routines using Bresenham's Algorithm...

I found that the Bresenham line-drawing method required that I specify 8 possible cases of line direction.  We'll call the change in X for a line (X2-X1) "DX" and the change in Y (Y2-Y1) "DY".  On the Atari screen, "down" means increasing Y-coordinate, "right" means increasing X-coordinate.
The cases are:

- Right Down Gentle (RDG) - DX and DY both positive, DX > DY
- Right Down Steep (RDS) - DX and DY both positive, DY > DX
- Right Up Gentle (RUG) - DX positive and DY negative, DX > DY
- Right Up Steep (RUS) - DX positive and DY negative, DY > DX

- Left Down Gentle (LDG) - DX negative and DY positive, DX > DY
- Left Down Steep (LDS) - DX negative and DY positive, DY > DX
- Left Up Gentle (LUG) - DX and DY both negative, DX > DY
- Left Up Steep (LUS) - DX and DY both negative, DY > DX

 I found that it made sense to separate these cases into 8 separate machines language routines.  If I'd created a generalized routine for all 8 cases, it would have taken much less space, but it would have been much slower.  With a generalized routine, I would have had to check for the case type every time I plotted a pixel, not good because minimizing the pixel-plotting loop renders the greatest overall speed increase.  Also, I was doing my best to stay away from negative numbers (necessary in a generalized routine) since I was doing single-byte arithmetic.  So I settled on 8 ML drawing routines.  I ultimately stored them as character strings in the Basic player, each string about 70 bytes long.  Through continual tweeking and optimizing, I got these routines to the point where I would now be hard-pressed to improve upon them.  I then added an ML routine in the player which would select the proper drawing routine from the two most recent pairs of coordinates read.  I also set up an "address table"in the Basic part of the player, so the main ML routine would know where to jump in memory to access the appropriate case drawing routine.

## Languages

Sometime during the time when I was going from the Basic drawing routines to ML drawing routines,  I started to use the DataSoft Basic Compiler to make faster, executable versions of the player.  The problem I ultimately found with DataSoft was that it would not compile programs with subscripted variables, unacceptable because I needed those variables for my "address table" to access case drawing routines.  I also tried writing the player in the ACTION language, which had pretty good speed for non-drawing functions (ACTION's drawing routines weren't any faster than Basic's).  However, ACTION wouldn't allow me to reserve a memory space for animations that was any larger than 8KB, so it was out.  Ultimately I discovered TurboBasic and TurboBasic Compiler on the Web, and they became my choice for the Atari player.  The only downside is that the player could now only be used on the XL/XE series of Ataris, not on the original Atari 800...

## Final Touches

At this point (sometime in July 2007) I had finally optimized the line-drawing routines so that it took less than 100 machine cycles per pixel to draw a line.  What was left was to incorporate the entire frame-drawing section into one ML program, add a nice interface to the Basic front-end of the player, and to add a timing mechanism so that all frames, regardless of complexity, were played at the same rate.  All this time, I managed to keep finding page 0 memory addresses I could use that were safe from the operating system (I ended up with 21 page 0 addresses).  Also, I originally tried to increase speed by not replotting (locating) the start of every segment on a polyline.  I tried instead just to use the final memory location from the previous segment as a starting point.  However, the "rounding error" was too great and animated figures looked like the drawings of a 2-year-old.  So I resigned myself to doing a new plot at the start of each line segment, and the figures looked fine.

The Basic front-end directory lister and filename prompt was added, and constant timing was remarkably easy to achieve in Basic.  Between frames I just PEEKed memory location 20 (14h), which is the smallest of the three digits of Atari's real-time clock.  The values are in jiffies (60ths of a second), so the jiffy value inputted by the user could simply be compared to the time elapsed since the previous frame. As I mentioned earlier, the AWM animations were modified by adding 6 bytes at the beginning of the file, containing the starting and ending memory addresses of where the file would be stored.  This allowed me to use TB's BLOAD instruction to rapidly read the animation file and store it in memory.

All that was now left was to integrate the frame-drawing section and the screen-clear routine into one big ML routine, and adapt the Turbo Basic player to call the routine at the proper time.  I avoided converting the entire play loop into ML because it wouldn't have allowed the user to gracefully exit the animation (with the <BREAK> key) and quickly load another one.  The Atari would have had to be rebooted after every animation.  Anyway, the Turbo Basic Player was compiled and renamed AUTORUN.CTB, so that it would run automatically when the disk was booted.  Similarly, the Turbo Basic Runtime Module, RUNTIME.COM, was renamed AUTORUN.SYS.  The ML Frame routine, FRAME.BIN, was included on the disk also, as well as several AWM animation files, which would appear in the opening menu when the disk was booted (thanks to Turbo Basic's DIR instruction).


Update 10/09 - FRAME.BIN and WHAM.BAS have now been revised to handle the FE control code.  FRAME.BIN resides on Page 6 of memory (a "safe" area), limited to the area from $600 to $6E7 (232 bytes).  This is because 2 arrays use up the other 24 bytes of Page 6 memory.
